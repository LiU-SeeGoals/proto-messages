// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.181.1
//   protoc               v3.12.4
// source: simulation/ssl_simulation_control.proto

/* eslint-disable */
import * as _m0 from "protobufjs/minimal";
import { SimRobotId } from "./ssl_gc_common";
import { SimulatorConfig } from "./ssl_simulation_config";
import { SimulatorError } from "./ssl_simulation_error";

export const protobufPackage = "";

/** Teleport the ball to a new location and optionally set it to some velocity */
export interface TeleportBall {
  /** x-coordinate [m] */
  x?:
    | number
    | undefined;
  /** y-coordinate [m] */
  y?:
    | number
    | undefined;
  /** z-coordinate (height) [m] */
  z?:
    | number
    | undefined;
  /** Velocity in x-direction [m/s] */
  vx?:
    | number
    | undefined;
  /** Velocity in y-direction [m/s] */
  vy?:
    | number
    | undefined;
  /** Velocity in z-direction [m/s] */
  vz?:
    | number
    | undefined;
  /**
   * Teleport the ball safely to the target, for example by
   * moving robots out of the way in case of collision and set speed of robots
   * close-by to zero
   */
  teleportSafely?:
    | boolean
    | undefined;
  /** Adapt the angular ball velocity such that the ball is rolling */
  roll?: boolean | undefined;
}

/** Teleport a robot to some location and give it a velocity */
export interface TeleportRobot {
  /** Robot id to teleport */
  id:
    | SimRobotId
    | undefined;
  /** x-coordinate [m] */
  x?:
    | number
    | undefined;
  /** y-coordinate [m] */
  y?:
    | number
    | undefined;
  /** Orientation [rad], measured from the x-axis counter-clockwise */
  orientation?:
    | number
    | undefined;
  /** Global velocity [m/s] towards x-axis */
  vX?:
    | number
    | undefined;
  /** Global velocity [m/s] towards y-axis */
  vY?:
    | number
    | undefined;
  /** Angular velocity [rad/s] */
  vAngular?:
    | number
    | undefined;
  /**
   * Robot should be present on the field?
   * true -> robot will be added, if it does not exist yet
   * false -> robot will be removed, if it is present
   */
  present?: boolean | undefined;
}

/** Control the simulation */
export interface SimulatorControl {
  /** Teleport the ball */
  teleportBall?:
    | TeleportBall
    | undefined;
  /** Teleport robots */
  teleportRobot: TeleportRobot[];
  /** Change the simulation speed */
  simulationSpeed?: number | undefined;
}

/** Command from the connected client to the simulator */
export interface SimulatorCommand {
  /** Control the simulation */
  control?:
    | SimulatorControl
    | undefined;
  /** Configure the simulation */
  config?: SimulatorConfig | undefined;
}

/** Response of the simulator to the connected client */
export interface SimulatorResponse {
  /** List of errors, like using unsupported features */
  errors: SimulatorError[];
}

function createBaseTeleportBall(): TeleportBall {
  return { x: 0, y: 0, z: 0, vx: 0, vy: 0, vz: 0, teleportSafely: false, roll: false };
}

export const TeleportBall = {
  encode(message: TeleportBall, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.x !== undefined && message.x !== 0) {
      writer.uint32(13).float(message.x);
    }
    if (message.y !== undefined && message.y !== 0) {
      writer.uint32(21).float(message.y);
    }
    if (message.z !== undefined && message.z !== 0) {
      writer.uint32(29).float(message.z);
    }
    if (message.vx !== undefined && message.vx !== 0) {
      writer.uint32(37).float(message.vx);
    }
    if (message.vy !== undefined && message.vy !== 0) {
      writer.uint32(45).float(message.vy);
    }
    if (message.vz !== undefined && message.vz !== 0) {
      writer.uint32(53).float(message.vz);
    }
    if (message.teleportSafely !== undefined && message.teleportSafely !== false) {
      writer.uint32(56).bool(message.teleportSafely);
    }
    if (message.roll !== undefined && message.roll !== false) {
      writer.uint32(64).bool(message.roll);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TeleportBall {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTeleportBall();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 13) {
            break;
          }

          message.x = reader.float();
          continue;
        case 2:
          if (tag !== 21) {
            break;
          }

          message.y = reader.float();
          continue;
        case 3:
          if (tag !== 29) {
            break;
          }

          message.z = reader.float();
          continue;
        case 4:
          if (tag !== 37) {
            break;
          }

          message.vx = reader.float();
          continue;
        case 5:
          if (tag !== 45) {
            break;
          }

          message.vy = reader.float();
          continue;
        case 6:
          if (tag !== 53) {
            break;
          }

          message.vz = reader.float();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.teleportSafely = reader.bool();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.roll = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TeleportBall {
    return {
      x: isSet(object.x) ? globalThis.Number(object.x) : 0,
      y: isSet(object.y) ? globalThis.Number(object.y) : 0,
      z: isSet(object.z) ? globalThis.Number(object.z) : 0,
      vx: isSet(object.vx) ? globalThis.Number(object.vx) : 0,
      vy: isSet(object.vy) ? globalThis.Number(object.vy) : 0,
      vz: isSet(object.vz) ? globalThis.Number(object.vz) : 0,
      teleportSafely: isSet(object.teleportSafely) ? globalThis.Boolean(object.teleportSafely) : false,
      roll: isSet(object.roll) ? globalThis.Boolean(object.roll) : false,
    };
  },

  toJSON(message: TeleportBall): unknown {
    const obj: any = {};
    if (message.x !== undefined && message.x !== 0) {
      obj.x = message.x;
    }
    if (message.y !== undefined && message.y !== 0) {
      obj.y = message.y;
    }
    if (message.z !== undefined && message.z !== 0) {
      obj.z = message.z;
    }
    if (message.vx !== undefined && message.vx !== 0) {
      obj.vx = message.vx;
    }
    if (message.vy !== undefined && message.vy !== 0) {
      obj.vy = message.vy;
    }
    if (message.vz !== undefined && message.vz !== 0) {
      obj.vz = message.vz;
    }
    if (message.teleportSafely !== undefined && message.teleportSafely !== false) {
      obj.teleportSafely = message.teleportSafely;
    }
    if (message.roll !== undefined && message.roll !== false) {
      obj.roll = message.roll;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TeleportBall>, I>>(base?: I): TeleportBall {
    return TeleportBall.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TeleportBall>, I>>(object: I): TeleportBall {
    const message = createBaseTeleportBall();
    message.x = object.x ?? 0;
    message.y = object.y ?? 0;
    message.z = object.z ?? 0;
    message.vx = object.vx ?? 0;
    message.vy = object.vy ?? 0;
    message.vz = object.vz ?? 0;
    message.teleportSafely = object.teleportSafely ?? false;
    message.roll = object.roll ?? false;
    return message;
  },
};

function createBaseTeleportRobot(): TeleportRobot {
  return { id: undefined, x: 0, y: 0, orientation: 0, vX: 0, vY: 0, vAngular: 0, present: false };
}

export const TeleportRobot = {
  encode(message: TeleportRobot, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== undefined) {
      SimRobotId.encode(message.id, writer.uint32(10).fork()).ldelim();
    }
    if (message.x !== undefined && message.x !== 0) {
      writer.uint32(21).float(message.x);
    }
    if (message.y !== undefined && message.y !== 0) {
      writer.uint32(29).float(message.y);
    }
    if (message.orientation !== undefined && message.orientation !== 0) {
      writer.uint32(37).float(message.orientation);
    }
    if (message.vX !== undefined && message.vX !== 0) {
      writer.uint32(45).float(message.vX);
    }
    if (message.vY !== undefined && message.vY !== 0) {
      writer.uint32(53).float(message.vY);
    }
    if (message.vAngular !== undefined && message.vAngular !== 0) {
      writer.uint32(61).float(message.vAngular);
    }
    if (message.present !== undefined && message.present !== false) {
      writer.uint32(64).bool(message.present);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TeleportRobot {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTeleportRobot();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = SimRobotId.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 21) {
            break;
          }

          message.x = reader.float();
          continue;
        case 3:
          if (tag !== 29) {
            break;
          }

          message.y = reader.float();
          continue;
        case 4:
          if (tag !== 37) {
            break;
          }

          message.orientation = reader.float();
          continue;
        case 5:
          if (tag !== 45) {
            break;
          }

          message.vX = reader.float();
          continue;
        case 6:
          if (tag !== 53) {
            break;
          }

          message.vY = reader.float();
          continue;
        case 7:
          if (tag !== 61) {
            break;
          }

          message.vAngular = reader.float();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.present = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TeleportRobot {
    return {
      id: isSet(object.id) ? SimRobotId.fromJSON(object.id) : undefined,
      x: isSet(object.x) ? globalThis.Number(object.x) : 0,
      y: isSet(object.y) ? globalThis.Number(object.y) : 0,
      orientation: isSet(object.orientation) ? globalThis.Number(object.orientation) : 0,
      vX: isSet(object.vX) ? globalThis.Number(object.vX) : 0,
      vY: isSet(object.vY) ? globalThis.Number(object.vY) : 0,
      vAngular: isSet(object.vAngular) ? globalThis.Number(object.vAngular) : 0,
      present: isSet(object.present) ? globalThis.Boolean(object.present) : false,
    };
  },

  toJSON(message: TeleportRobot): unknown {
    const obj: any = {};
    if (message.id !== undefined) {
      obj.id = SimRobotId.toJSON(message.id);
    }
    if (message.x !== undefined && message.x !== 0) {
      obj.x = message.x;
    }
    if (message.y !== undefined && message.y !== 0) {
      obj.y = message.y;
    }
    if (message.orientation !== undefined && message.orientation !== 0) {
      obj.orientation = message.orientation;
    }
    if (message.vX !== undefined && message.vX !== 0) {
      obj.vX = message.vX;
    }
    if (message.vY !== undefined && message.vY !== 0) {
      obj.vY = message.vY;
    }
    if (message.vAngular !== undefined && message.vAngular !== 0) {
      obj.vAngular = message.vAngular;
    }
    if (message.present !== undefined && message.present !== false) {
      obj.present = message.present;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TeleportRobot>, I>>(base?: I): TeleportRobot {
    return TeleportRobot.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TeleportRobot>, I>>(object: I): TeleportRobot {
    const message = createBaseTeleportRobot();
    message.id = (object.id !== undefined && object.id !== null) ? SimRobotId.fromPartial(object.id) : undefined;
    message.x = object.x ?? 0;
    message.y = object.y ?? 0;
    message.orientation = object.orientation ?? 0;
    message.vX = object.vX ?? 0;
    message.vY = object.vY ?? 0;
    message.vAngular = object.vAngular ?? 0;
    message.present = object.present ?? false;
    return message;
  },
};

function createBaseSimulatorControl(): SimulatorControl {
  return { teleportBall: undefined, teleportRobot: [], simulationSpeed: 0 };
}

export const SimulatorControl = {
  encode(message: SimulatorControl, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.teleportBall !== undefined) {
      TeleportBall.encode(message.teleportBall, writer.uint32(10).fork()).ldelim();
    }
    for (const v of message.teleportRobot) {
      TeleportRobot.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    if (message.simulationSpeed !== undefined && message.simulationSpeed !== 0) {
      writer.uint32(29).float(message.simulationSpeed);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SimulatorControl {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSimulatorControl();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.teleportBall = TeleportBall.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.teleportRobot.push(TeleportRobot.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 29) {
            break;
          }

          message.simulationSpeed = reader.float();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SimulatorControl {
    return {
      teleportBall: isSet(object.teleportBall) ? TeleportBall.fromJSON(object.teleportBall) : undefined,
      teleportRobot: globalThis.Array.isArray(object?.teleportRobot)
        ? object.teleportRobot.map((e: any) => TeleportRobot.fromJSON(e))
        : [],
      simulationSpeed: isSet(object.simulationSpeed) ? globalThis.Number(object.simulationSpeed) : 0,
    };
  },

  toJSON(message: SimulatorControl): unknown {
    const obj: any = {};
    if (message.teleportBall !== undefined) {
      obj.teleportBall = TeleportBall.toJSON(message.teleportBall);
    }
    if (message.teleportRobot?.length) {
      obj.teleportRobot = message.teleportRobot.map((e) => TeleportRobot.toJSON(e));
    }
    if (message.simulationSpeed !== undefined && message.simulationSpeed !== 0) {
      obj.simulationSpeed = message.simulationSpeed;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SimulatorControl>, I>>(base?: I): SimulatorControl {
    return SimulatorControl.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SimulatorControl>, I>>(object: I): SimulatorControl {
    const message = createBaseSimulatorControl();
    message.teleportBall = (object.teleportBall !== undefined && object.teleportBall !== null)
      ? TeleportBall.fromPartial(object.teleportBall)
      : undefined;
    message.teleportRobot = object.teleportRobot?.map((e) => TeleportRobot.fromPartial(e)) || [];
    message.simulationSpeed = object.simulationSpeed ?? 0;
    return message;
  },
};

function createBaseSimulatorCommand(): SimulatorCommand {
  return { control: undefined, config: undefined };
}

export const SimulatorCommand = {
  encode(message: SimulatorCommand, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.control !== undefined) {
      SimulatorControl.encode(message.control, writer.uint32(10).fork()).ldelim();
    }
    if (message.config !== undefined) {
      SimulatorConfig.encode(message.config, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SimulatorCommand {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSimulatorCommand();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.control = SimulatorControl.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.config = SimulatorConfig.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SimulatorCommand {
    return {
      control: isSet(object.control) ? SimulatorControl.fromJSON(object.control) : undefined,
      config: isSet(object.config) ? SimulatorConfig.fromJSON(object.config) : undefined,
    };
  },

  toJSON(message: SimulatorCommand): unknown {
    const obj: any = {};
    if (message.control !== undefined) {
      obj.control = SimulatorControl.toJSON(message.control);
    }
    if (message.config !== undefined) {
      obj.config = SimulatorConfig.toJSON(message.config);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SimulatorCommand>, I>>(base?: I): SimulatorCommand {
    return SimulatorCommand.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SimulatorCommand>, I>>(object: I): SimulatorCommand {
    const message = createBaseSimulatorCommand();
    message.control = (object.control !== undefined && object.control !== null)
      ? SimulatorControl.fromPartial(object.control)
      : undefined;
    message.config = (object.config !== undefined && object.config !== null)
      ? SimulatorConfig.fromPartial(object.config)
      : undefined;
    return message;
  },
};

function createBaseSimulatorResponse(): SimulatorResponse {
  return { errors: [] };
}

export const SimulatorResponse = {
  encode(message: SimulatorResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.errors) {
      SimulatorError.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SimulatorResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSimulatorResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.errors.push(SimulatorError.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SimulatorResponse {
    return {
      errors: globalThis.Array.isArray(object?.errors) ? object.errors.map((e: any) => SimulatorError.fromJSON(e)) : [],
    };
  },

  toJSON(message: SimulatorResponse): unknown {
    const obj: any = {};
    if (message.errors?.length) {
      obj.errors = message.errors.map((e) => SimulatorError.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SimulatorResponse>, I>>(base?: I): SimulatorResponse {
    return SimulatorResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SimulatorResponse>, I>>(object: I): SimulatorResponse {
    const message = createBaseSimulatorResponse();
    message.errors = object.errors?.map((e) => SimulatorError.fromPartial(e)) || [];
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}
