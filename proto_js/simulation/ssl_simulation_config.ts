// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.181.1
//   protoc               v3.12.4
// source: simulation/ssl_simulation_config.proto

/* eslint-disable */
import * as _m0 from "protobufjs/minimal";
import { Any } from "../google/protobuf/any";
import { SSLGeometryData } from "../ssl_vision/ssl_vision_geometry";
import { SimRobotId } from "./ssl_gc_common";

export const protobufPackage = "";

/** Movement limits for a robot */
export interface RobotLimits {
  /** Max absolute speed-up acceleration [m/s^2] */
  accSpeedupAbsoluteMax?:
    | number
    | undefined;
  /** Max angular speed-up acceleration [rad/s^2] */
  accSpeedupAngularMax?:
    | number
    | undefined;
  /** Max absolute brake acceleration [m/s^2] */
  accBrakeAbsoluteMax?:
    | number
    | undefined;
  /** Max angular brake acceleration [rad/s^2] */
  accBrakeAngularMax?:
    | number
    | undefined;
  /** Max absolute velocity [m/s] */
  velAbsoluteMax?:
    | number
    | undefined;
  /** Max angular velocity [rad/s] */
  velAngularMax?: number | undefined;
}

/**
 * Robot wheel angle configuration
 * all angles are relative to looking forward,
 * all wheels / angles are clockwise
 */
export interface RobotWheelAngles {
  /** Angle front right [rad] */
  frontRight: number;
  /** Angle back right [rad] */
  backRight: number;
  /** Angle back left [rad] */
  backLeft: number;
  /** Angle front left [rad] */
  frontLeft: number;
}

/** Specs of a robot */
export interface RobotSpecs {
  /** Id of the robot */
  id:
    | SimRobotId
    | undefined;
  /** Robot radius [m] */
  radius?:
    | number
    | undefined;
  /** Robot height [m] */
  height?:
    | number
    | undefined;
  /** Robot mass [kg] */
  mass?:
    | number
    | undefined;
  /** Max linear kick speed [m/s] (unset = unlimited) */
  maxLinearKickSpeed?:
    | number
    | undefined;
  /** Max chip kick speed [m/s] (unset = unlimited) */
  maxChipKickSpeed?:
    | number
    | undefined;
  /**
   * Distance from robot center to dribbler [m] (implicitly defines the opening
   * angle and dribbler width)
   */
  centerToDribbler?:
    | number
    | undefined;
  /** Movement limits */
  limits?:
    | RobotLimits
    | undefined;
  /** Wheel angle configuration */
  wheelAngles?:
    | RobotWheelAngles
    | undefined;
  /**
   * Custom robot spec for specific simulators (the protobuf files are managed
   * by the simulators)
   */
  custom?: Any | undefined;
}

export interface RealismConfig {
  /**
   * Custom config for specific simulators (the protobuf files are managed by
   * the simulators)
   */
  custom?: Any | undefined;
}

/** Change the simulator configuration */
export interface SimulatorConfig {
  /** Update the geometry */
  geometry?:
    | SSLGeometryData
    | undefined;
  /** Update the robot specs */
  robotSpecs: RobotSpecs[];
  /** Update realism configuration */
  realismConfig?:
    | RealismConfig
    | undefined;
  /** Change the vision publish port */
  visionPort?: number | undefined;
}

function createBaseRobotLimits(): RobotLimits {
  return {
    accSpeedupAbsoluteMax: 0,
    accSpeedupAngularMax: 0,
    accBrakeAbsoluteMax: 0,
    accBrakeAngularMax: 0,
    velAbsoluteMax: 0,
    velAngularMax: 0,
  };
}

export const RobotLimits = {
  encode(message: RobotLimits, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.accSpeedupAbsoluteMax !== undefined && message.accSpeedupAbsoluteMax !== 0) {
      writer.uint32(13).float(message.accSpeedupAbsoluteMax);
    }
    if (message.accSpeedupAngularMax !== undefined && message.accSpeedupAngularMax !== 0) {
      writer.uint32(21).float(message.accSpeedupAngularMax);
    }
    if (message.accBrakeAbsoluteMax !== undefined && message.accBrakeAbsoluteMax !== 0) {
      writer.uint32(29).float(message.accBrakeAbsoluteMax);
    }
    if (message.accBrakeAngularMax !== undefined && message.accBrakeAngularMax !== 0) {
      writer.uint32(37).float(message.accBrakeAngularMax);
    }
    if (message.velAbsoluteMax !== undefined && message.velAbsoluteMax !== 0) {
      writer.uint32(45).float(message.velAbsoluteMax);
    }
    if (message.velAngularMax !== undefined && message.velAngularMax !== 0) {
      writer.uint32(53).float(message.velAngularMax);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): RobotLimits {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRobotLimits();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 13) {
            break;
          }

          message.accSpeedupAbsoluteMax = reader.float();
          continue;
        case 2:
          if (tag !== 21) {
            break;
          }

          message.accSpeedupAngularMax = reader.float();
          continue;
        case 3:
          if (tag !== 29) {
            break;
          }

          message.accBrakeAbsoluteMax = reader.float();
          continue;
        case 4:
          if (tag !== 37) {
            break;
          }

          message.accBrakeAngularMax = reader.float();
          continue;
        case 5:
          if (tag !== 45) {
            break;
          }

          message.velAbsoluteMax = reader.float();
          continue;
        case 6:
          if (tag !== 53) {
            break;
          }

          message.velAngularMax = reader.float();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RobotLimits {
    return {
      accSpeedupAbsoluteMax: isSet(object.accSpeedupAbsoluteMax) ? globalThis.Number(object.accSpeedupAbsoluteMax) : 0,
      accSpeedupAngularMax: isSet(object.accSpeedupAngularMax) ? globalThis.Number(object.accSpeedupAngularMax) : 0,
      accBrakeAbsoluteMax: isSet(object.accBrakeAbsoluteMax) ? globalThis.Number(object.accBrakeAbsoluteMax) : 0,
      accBrakeAngularMax: isSet(object.accBrakeAngularMax) ? globalThis.Number(object.accBrakeAngularMax) : 0,
      velAbsoluteMax: isSet(object.velAbsoluteMax) ? globalThis.Number(object.velAbsoluteMax) : 0,
      velAngularMax: isSet(object.velAngularMax) ? globalThis.Number(object.velAngularMax) : 0,
    };
  },

  toJSON(message: RobotLimits): unknown {
    const obj: any = {};
    if (message.accSpeedupAbsoluteMax !== undefined && message.accSpeedupAbsoluteMax !== 0) {
      obj.accSpeedupAbsoluteMax = message.accSpeedupAbsoluteMax;
    }
    if (message.accSpeedupAngularMax !== undefined && message.accSpeedupAngularMax !== 0) {
      obj.accSpeedupAngularMax = message.accSpeedupAngularMax;
    }
    if (message.accBrakeAbsoluteMax !== undefined && message.accBrakeAbsoluteMax !== 0) {
      obj.accBrakeAbsoluteMax = message.accBrakeAbsoluteMax;
    }
    if (message.accBrakeAngularMax !== undefined && message.accBrakeAngularMax !== 0) {
      obj.accBrakeAngularMax = message.accBrakeAngularMax;
    }
    if (message.velAbsoluteMax !== undefined && message.velAbsoluteMax !== 0) {
      obj.velAbsoluteMax = message.velAbsoluteMax;
    }
    if (message.velAngularMax !== undefined && message.velAngularMax !== 0) {
      obj.velAngularMax = message.velAngularMax;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RobotLimits>, I>>(base?: I): RobotLimits {
    return RobotLimits.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RobotLimits>, I>>(object: I): RobotLimits {
    const message = createBaseRobotLimits();
    message.accSpeedupAbsoluteMax = object.accSpeedupAbsoluteMax ?? 0;
    message.accSpeedupAngularMax = object.accSpeedupAngularMax ?? 0;
    message.accBrakeAbsoluteMax = object.accBrakeAbsoluteMax ?? 0;
    message.accBrakeAngularMax = object.accBrakeAngularMax ?? 0;
    message.velAbsoluteMax = object.velAbsoluteMax ?? 0;
    message.velAngularMax = object.velAngularMax ?? 0;
    return message;
  },
};

function createBaseRobotWheelAngles(): RobotWheelAngles {
  return { frontRight: 0, backRight: 0, backLeft: 0, frontLeft: 0 };
}

export const RobotWheelAngles = {
  encode(message: RobotWheelAngles, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.frontRight !== 0) {
      writer.uint32(13).float(message.frontRight);
    }
    if (message.backRight !== 0) {
      writer.uint32(21).float(message.backRight);
    }
    if (message.backLeft !== 0) {
      writer.uint32(29).float(message.backLeft);
    }
    if (message.frontLeft !== 0) {
      writer.uint32(37).float(message.frontLeft);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): RobotWheelAngles {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRobotWheelAngles();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 13) {
            break;
          }

          message.frontRight = reader.float();
          continue;
        case 2:
          if (tag !== 21) {
            break;
          }

          message.backRight = reader.float();
          continue;
        case 3:
          if (tag !== 29) {
            break;
          }

          message.backLeft = reader.float();
          continue;
        case 4:
          if (tag !== 37) {
            break;
          }

          message.frontLeft = reader.float();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RobotWheelAngles {
    return {
      frontRight: isSet(object.frontRight) ? globalThis.Number(object.frontRight) : 0,
      backRight: isSet(object.backRight) ? globalThis.Number(object.backRight) : 0,
      backLeft: isSet(object.backLeft) ? globalThis.Number(object.backLeft) : 0,
      frontLeft: isSet(object.frontLeft) ? globalThis.Number(object.frontLeft) : 0,
    };
  },

  toJSON(message: RobotWheelAngles): unknown {
    const obj: any = {};
    if (message.frontRight !== 0) {
      obj.frontRight = message.frontRight;
    }
    if (message.backRight !== 0) {
      obj.backRight = message.backRight;
    }
    if (message.backLeft !== 0) {
      obj.backLeft = message.backLeft;
    }
    if (message.frontLeft !== 0) {
      obj.frontLeft = message.frontLeft;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RobotWheelAngles>, I>>(base?: I): RobotWheelAngles {
    return RobotWheelAngles.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RobotWheelAngles>, I>>(object: I): RobotWheelAngles {
    const message = createBaseRobotWheelAngles();
    message.frontRight = object.frontRight ?? 0;
    message.backRight = object.backRight ?? 0;
    message.backLeft = object.backLeft ?? 0;
    message.frontLeft = object.frontLeft ?? 0;
    return message;
  },
};

function createBaseRobotSpecs(): RobotSpecs {
  return {
    id: undefined,
    radius: 0.09,
    height: 0.15,
    mass: 0,
    maxLinearKickSpeed: 0,
    maxChipKickSpeed: 0,
    centerToDribbler: 0,
    limits: undefined,
    wheelAngles: undefined,
    custom: undefined,
  };
}

export const RobotSpecs = {
  encode(message: RobotSpecs, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== undefined) {
      SimRobotId.encode(message.id, writer.uint32(10).fork()).ldelim();
    }
    if (message.radius !== undefined && message.radius !== 0.09) {
      writer.uint32(21).float(message.radius);
    }
    if (message.height !== undefined && message.height !== 0.15) {
      writer.uint32(29).float(message.height);
    }
    if (message.mass !== undefined && message.mass !== 0) {
      writer.uint32(37).float(message.mass);
    }
    if (message.maxLinearKickSpeed !== undefined && message.maxLinearKickSpeed !== 0) {
      writer.uint32(61).float(message.maxLinearKickSpeed);
    }
    if (message.maxChipKickSpeed !== undefined && message.maxChipKickSpeed !== 0) {
      writer.uint32(69).float(message.maxChipKickSpeed);
    }
    if (message.centerToDribbler !== undefined && message.centerToDribbler !== 0) {
      writer.uint32(77).float(message.centerToDribbler);
    }
    if (message.limits !== undefined) {
      RobotLimits.encode(message.limits, writer.uint32(82).fork()).ldelim();
    }
    if (message.wheelAngles !== undefined) {
      RobotWheelAngles.encode(message.wheelAngles, writer.uint32(106).fork()).ldelim();
    }
    if (message.custom !== undefined) {
      Any.encode(message.custom, writer.uint32(114).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): RobotSpecs {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRobotSpecs();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = SimRobotId.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 21) {
            break;
          }

          message.radius = reader.float();
          continue;
        case 3:
          if (tag !== 29) {
            break;
          }

          message.height = reader.float();
          continue;
        case 4:
          if (tag !== 37) {
            break;
          }

          message.mass = reader.float();
          continue;
        case 7:
          if (tag !== 61) {
            break;
          }

          message.maxLinearKickSpeed = reader.float();
          continue;
        case 8:
          if (tag !== 69) {
            break;
          }

          message.maxChipKickSpeed = reader.float();
          continue;
        case 9:
          if (tag !== 77) {
            break;
          }

          message.centerToDribbler = reader.float();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.limits = RobotLimits.decode(reader, reader.uint32());
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.wheelAngles = RobotWheelAngles.decode(reader, reader.uint32());
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }

          message.custom = Any.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RobotSpecs {
    return {
      id: isSet(object.id) ? SimRobotId.fromJSON(object.id) : undefined,
      radius: isSet(object.radius) ? globalThis.Number(object.radius) : 0.09,
      height: isSet(object.height) ? globalThis.Number(object.height) : 0.15,
      mass: isSet(object.mass) ? globalThis.Number(object.mass) : 0,
      maxLinearKickSpeed: isSet(object.maxLinearKickSpeed) ? globalThis.Number(object.maxLinearKickSpeed) : 0,
      maxChipKickSpeed: isSet(object.maxChipKickSpeed) ? globalThis.Number(object.maxChipKickSpeed) : 0,
      centerToDribbler: isSet(object.centerToDribbler) ? globalThis.Number(object.centerToDribbler) : 0,
      limits: isSet(object.limits) ? RobotLimits.fromJSON(object.limits) : undefined,
      wheelAngles: isSet(object.wheelAngles) ? RobotWheelAngles.fromJSON(object.wheelAngles) : undefined,
      custom: isSet(object.custom) ? Any.fromJSON(object.custom) : undefined,
    };
  },

  toJSON(message: RobotSpecs): unknown {
    const obj: any = {};
    if (message.id !== undefined) {
      obj.id = SimRobotId.toJSON(message.id);
    }
    if (message.radius !== undefined && message.radius !== 0.09) {
      obj.radius = message.radius;
    }
    if (message.height !== undefined && message.height !== 0.15) {
      obj.height = message.height;
    }
    if (message.mass !== undefined && message.mass !== 0) {
      obj.mass = message.mass;
    }
    if (message.maxLinearKickSpeed !== undefined && message.maxLinearKickSpeed !== 0) {
      obj.maxLinearKickSpeed = message.maxLinearKickSpeed;
    }
    if (message.maxChipKickSpeed !== undefined && message.maxChipKickSpeed !== 0) {
      obj.maxChipKickSpeed = message.maxChipKickSpeed;
    }
    if (message.centerToDribbler !== undefined && message.centerToDribbler !== 0) {
      obj.centerToDribbler = message.centerToDribbler;
    }
    if (message.limits !== undefined) {
      obj.limits = RobotLimits.toJSON(message.limits);
    }
    if (message.wheelAngles !== undefined) {
      obj.wheelAngles = RobotWheelAngles.toJSON(message.wheelAngles);
    }
    if (message.custom !== undefined) {
      obj.custom = Any.toJSON(message.custom);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RobotSpecs>, I>>(base?: I): RobotSpecs {
    return RobotSpecs.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RobotSpecs>, I>>(object: I): RobotSpecs {
    const message = createBaseRobotSpecs();
    message.id = (object.id !== undefined && object.id !== null) ? SimRobotId.fromPartial(object.id) : undefined;
    message.radius = object.radius ?? 0.09;
    message.height = object.height ?? 0.15;
    message.mass = object.mass ?? 0;
    message.maxLinearKickSpeed = object.maxLinearKickSpeed ?? 0;
    message.maxChipKickSpeed = object.maxChipKickSpeed ?? 0;
    message.centerToDribbler = object.centerToDribbler ?? 0;
    message.limits = (object.limits !== undefined && object.limits !== null)
      ? RobotLimits.fromPartial(object.limits)
      : undefined;
    message.wheelAngles = (object.wheelAngles !== undefined && object.wheelAngles !== null)
      ? RobotWheelAngles.fromPartial(object.wheelAngles)
      : undefined;
    message.custom = (object.custom !== undefined && object.custom !== null)
      ? Any.fromPartial(object.custom)
      : undefined;
    return message;
  },
};

function createBaseRealismConfig(): RealismConfig {
  return { custom: undefined };
}

export const RealismConfig = {
  encode(message: RealismConfig, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.custom !== undefined) {
      Any.encode(message.custom, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): RealismConfig {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRealismConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.custom = Any.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RealismConfig {
    return { custom: isSet(object.custom) ? Any.fromJSON(object.custom) : undefined };
  },

  toJSON(message: RealismConfig): unknown {
    const obj: any = {};
    if (message.custom !== undefined) {
      obj.custom = Any.toJSON(message.custom);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RealismConfig>, I>>(base?: I): RealismConfig {
    return RealismConfig.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RealismConfig>, I>>(object: I): RealismConfig {
    const message = createBaseRealismConfig();
    message.custom = (object.custom !== undefined && object.custom !== null)
      ? Any.fromPartial(object.custom)
      : undefined;
    return message;
  },
};

function createBaseSimulatorConfig(): SimulatorConfig {
  return { geometry: undefined, robotSpecs: [], realismConfig: undefined, visionPort: 0 };
}

export const SimulatorConfig = {
  encode(message: SimulatorConfig, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.geometry !== undefined) {
      SSLGeometryData.encode(message.geometry, writer.uint32(10).fork()).ldelim();
    }
    for (const v of message.robotSpecs) {
      RobotSpecs.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    if (message.realismConfig !== undefined) {
      RealismConfig.encode(message.realismConfig, writer.uint32(26).fork()).ldelim();
    }
    if (message.visionPort !== undefined && message.visionPort !== 0) {
      writer.uint32(32).uint32(message.visionPort);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SimulatorConfig {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSimulatorConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.geometry = SSLGeometryData.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.robotSpecs.push(RobotSpecs.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.realismConfig = RealismConfig.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.visionPort = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SimulatorConfig {
    return {
      geometry: isSet(object.geometry) ? SSLGeometryData.fromJSON(object.geometry) : undefined,
      robotSpecs: globalThis.Array.isArray(object?.robotSpecs)
        ? object.robotSpecs.map((e: any) => RobotSpecs.fromJSON(e))
        : [],
      realismConfig: isSet(object.realismConfig) ? RealismConfig.fromJSON(object.realismConfig) : undefined,
      visionPort: isSet(object.visionPort) ? globalThis.Number(object.visionPort) : 0,
    };
  },

  toJSON(message: SimulatorConfig): unknown {
    const obj: any = {};
    if (message.geometry !== undefined) {
      obj.geometry = SSLGeometryData.toJSON(message.geometry);
    }
    if (message.robotSpecs?.length) {
      obj.robotSpecs = message.robotSpecs.map((e) => RobotSpecs.toJSON(e));
    }
    if (message.realismConfig !== undefined) {
      obj.realismConfig = RealismConfig.toJSON(message.realismConfig);
    }
    if (message.visionPort !== undefined && message.visionPort !== 0) {
      obj.visionPort = Math.round(message.visionPort);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SimulatorConfig>, I>>(base?: I): SimulatorConfig {
    return SimulatorConfig.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SimulatorConfig>, I>>(object: I): SimulatorConfig {
    const message = createBaseSimulatorConfig();
    message.geometry = (object.geometry !== undefined && object.geometry !== null)
      ? SSLGeometryData.fromPartial(object.geometry)
      : undefined;
    message.robotSpecs = object.robotSpecs?.map((e) => RobotSpecs.fromPartial(e)) || [];
    message.realismConfig = (object.realismConfig !== undefined && object.realismConfig !== null)
      ? RealismConfig.fromPartial(object.realismConfig)
      : undefined;
    message.visionPort = object.visionPort ?? 0;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}
