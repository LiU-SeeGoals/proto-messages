// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.181.1
//   protoc               v3.12.4
// source: ssl_vision/ssl_vision_detection.proto

/* eslint-disable */
import * as _m0 from "protobufjs/minimal";

export const protobufPackage = "";

export interface SSLDetectionBall {
  /** Confidence in [0-1] of the detection */
  confidence: number;
  area?:
    | number
    | undefined;
  /** X-coordinate in [mm] in global ssl-vision coordinate system */
  x: number;
  /** Y-coordinate in [mm] in global ssl-vision coordinate system */
  y: number;
  /**
   * Z-coordinate in [mm] in global ssl-vision coordinate system
   * Not supported by ssl-vision, but might be set by simulators
   */
  z?:
    | number
    | undefined;
  /** X-coordinate in [pixel] in the image */
  pixelX: number;
  /** Y-coordinate in [pixel] in the image */
  pixelY: number;
}

export interface SSLDetectionRobot {
  /** Confidence in [0-1] of the detection */
  confidence: number;
  /** Id of the robot */
  robotId?:
    | number
    | undefined;
  /** X-coordinate in [mm] in global ssl-vision coordinate system */
  x: number;
  /** Y-coordinate in [mm] in global ssl-vision coordinate system */
  y: number;
  /** Orientation in [rad] */
  orientation?:
    | number
    | undefined;
  /** X-coordinate in [pixel] in the image */
  pixelX: number;
  /** Y-coordinate in [pixel] in the image */
  pixelY: number;
  /** Height, as configured in ssl-vision for the respective team */
  height?: number | undefined;
}

export interface SSLDetectionFrame {
  /** monotonously increasing frame number */
  frameNumber: number;
  /**
   * Unix timestamp in [seconds] at which the image has been received by
   * ssl-vision
   */
  tCapture: number;
  /**
   * Unix timestamp in [seconds] at which this message has been sent to the
   * network
   */
  tSent: number;
  /**
   * Camera timestamp in [seconds] as reported by the camera, if supported
   * This is not necessarily a unix timestamp
   */
  tCaptureCamera?:
    | number
    | undefined;
  /** Identifier of the camera */
  cameraId: number;
  /** Detected balls */
  balls: SSLDetectionBall[];
  /** Detected yellow robots */
  robotsYellow: SSLDetectionRobot[];
  /** Detected blue robots */
  robotsBlue: SSLDetectionRobot[];
}

function createBaseSSLDetectionBall(): SSLDetectionBall {
  return { confidence: 0, area: 0, x: 0, y: 0, z: 0, pixelX: 0, pixelY: 0 };
}

export const SSLDetectionBall = {
  encode(message: SSLDetectionBall, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.confidence !== 0) {
      writer.uint32(13).float(message.confidence);
    }
    if (message.area !== undefined && message.area !== 0) {
      writer.uint32(16).uint32(message.area);
    }
    if (message.x !== 0) {
      writer.uint32(29).float(message.x);
    }
    if (message.y !== 0) {
      writer.uint32(37).float(message.y);
    }
    if (message.z !== undefined && message.z !== 0) {
      writer.uint32(45).float(message.z);
    }
    if (message.pixelX !== 0) {
      writer.uint32(53).float(message.pixelX);
    }
    if (message.pixelY !== 0) {
      writer.uint32(61).float(message.pixelY);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SSLDetectionBall {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSSLDetectionBall();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 13) {
            break;
          }

          message.confidence = reader.float();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.area = reader.uint32();
          continue;
        case 3:
          if (tag !== 29) {
            break;
          }

          message.x = reader.float();
          continue;
        case 4:
          if (tag !== 37) {
            break;
          }

          message.y = reader.float();
          continue;
        case 5:
          if (tag !== 45) {
            break;
          }

          message.z = reader.float();
          continue;
        case 6:
          if (tag !== 53) {
            break;
          }

          message.pixelX = reader.float();
          continue;
        case 7:
          if (tag !== 61) {
            break;
          }

          message.pixelY = reader.float();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SSLDetectionBall {
    return {
      confidence: isSet(object.confidence) ? globalThis.Number(object.confidence) : 0,
      area: isSet(object.area) ? globalThis.Number(object.area) : 0,
      x: isSet(object.x) ? globalThis.Number(object.x) : 0,
      y: isSet(object.y) ? globalThis.Number(object.y) : 0,
      z: isSet(object.z) ? globalThis.Number(object.z) : 0,
      pixelX: isSet(object.pixelX) ? globalThis.Number(object.pixelX) : 0,
      pixelY: isSet(object.pixelY) ? globalThis.Number(object.pixelY) : 0,
    };
  },

  toJSON(message: SSLDetectionBall): unknown {
    const obj: any = {};
    if (message.confidence !== 0) {
      obj.confidence = message.confidence;
    }
    if (message.area !== undefined && message.area !== 0) {
      obj.area = Math.round(message.area);
    }
    if (message.x !== 0) {
      obj.x = message.x;
    }
    if (message.y !== 0) {
      obj.y = message.y;
    }
    if (message.z !== undefined && message.z !== 0) {
      obj.z = message.z;
    }
    if (message.pixelX !== 0) {
      obj.pixelX = message.pixelX;
    }
    if (message.pixelY !== 0) {
      obj.pixelY = message.pixelY;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SSLDetectionBall>, I>>(base?: I): SSLDetectionBall {
    return SSLDetectionBall.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SSLDetectionBall>, I>>(object: I): SSLDetectionBall {
    const message = createBaseSSLDetectionBall();
    message.confidence = object.confidence ?? 0;
    message.area = object.area ?? 0;
    message.x = object.x ?? 0;
    message.y = object.y ?? 0;
    message.z = object.z ?? 0;
    message.pixelX = object.pixelX ?? 0;
    message.pixelY = object.pixelY ?? 0;
    return message;
  },
};

function createBaseSSLDetectionRobot(): SSLDetectionRobot {
  return { confidence: 0, robotId: 0, x: 0, y: 0, orientation: 0, pixelX: 0, pixelY: 0, height: 0 };
}

export const SSLDetectionRobot = {
  encode(message: SSLDetectionRobot, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.confidence !== 0) {
      writer.uint32(13).float(message.confidence);
    }
    if (message.robotId !== undefined && message.robotId !== 0) {
      writer.uint32(16).uint32(message.robotId);
    }
    if (message.x !== 0) {
      writer.uint32(29).float(message.x);
    }
    if (message.y !== 0) {
      writer.uint32(37).float(message.y);
    }
    if (message.orientation !== undefined && message.orientation !== 0) {
      writer.uint32(45).float(message.orientation);
    }
    if (message.pixelX !== 0) {
      writer.uint32(53).float(message.pixelX);
    }
    if (message.pixelY !== 0) {
      writer.uint32(61).float(message.pixelY);
    }
    if (message.height !== undefined && message.height !== 0) {
      writer.uint32(69).float(message.height);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SSLDetectionRobot {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSSLDetectionRobot();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 13) {
            break;
          }

          message.confidence = reader.float();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.robotId = reader.uint32();
          continue;
        case 3:
          if (tag !== 29) {
            break;
          }

          message.x = reader.float();
          continue;
        case 4:
          if (tag !== 37) {
            break;
          }

          message.y = reader.float();
          continue;
        case 5:
          if (tag !== 45) {
            break;
          }

          message.orientation = reader.float();
          continue;
        case 6:
          if (tag !== 53) {
            break;
          }

          message.pixelX = reader.float();
          continue;
        case 7:
          if (tag !== 61) {
            break;
          }

          message.pixelY = reader.float();
          continue;
        case 8:
          if (tag !== 69) {
            break;
          }

          message.height = reader.float();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SSLDetectionRobot {
    return {
      confidence: isSet(object.confidence) ? globalThis.Number(object.confidence) : 0,
      robotId: isSet(object.robotId) ? globalThis.Number(object.robotId) : 0,
      x: isSet(object.x) ? globalThis.Number(object.x) : 0,
      y: isSet(object.y) ? globalThis.Number(object.y) : 0,
      orientation: isSet(object.orientation) ? globalThis.Number(object.orientation) : 0,
      pixelX: isSet(object.pixelX) ? globalThis.Number(object.pixelX) : 0,
      pixelY: isSet(object.pixelY) ? globalThis.Number(object.pixelY) : 0,
      height: isSet(object.height) ? globalThis.Number(object.height) : 0,
    };
  },

  toJSON(message: SSLDetectionRobot): unknown {
    const obj: any = {};
    if (message.confidence !== 0) {
      obj.confidence = message.confidence;
    }
    if (message.robotId !== undefined && message.robotId !== 0) {
      obj.robotId = Math.round(message.robotId);
    }
    if (message.x !== 0) {
      obj.x = message.x;
    }
    if (message.y !== 0) {
      obj.y = message.y;
    }
    if (message.orientation !== undefined && message.orientation !== 0) {
      obj.orientation = message.orientation;
    }
    if (message.pixelX !== 0) {
      obj.pixelX = message.pixelX;
    }
    if (message.pixelY !== 0) {
      obj.pixelY = message.pixelY;
    }
    if (message.height !== undefined && message.height !== 0) {
      obj.height = message.height;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SSLDetectionRobot>, I>>(base?: I): SSLDetectionRobot {
    return SSLDetectionRobot.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SSLDetectionRobot>, I>>(object: I): SSLDetectionRobot {
    const message = createBaseSSLDetectionRobot();
    message.confidence = object.confidence ?? 0;
    message.robotId = object.robotId ?? 0;
    message.x = object.x ?? 0;
    message.y = object.y ?? 0;
    message.orientation = object.orientation ?? 0;
    message.pixelX = object.pixelX ?? 0;
    message.pixelY = object.pixelY ?? 0;
    message.height = object.height ?? 0;
    return message;
  },
};

function createBaseSSLDetectionFrame(): SSLDetectionFrame {
  return {
    frameNumber: 0,
    tCapture: 0,
    tSent: 0,
    tCaptureCamera: 0,
    cameraId: 0,
    balls: [],
    robotsYellow: [],
    robotsBlue: [],
  };
}

export const SSLDetectionFrame = {
  encode(message: SSLDetectionFrame, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.frameNumber !== 0) {
      writer.uint32(8).uint32(message.frameNumber);
    }
    if (message.tCapture !== 0) {
      writer.uint32(17).double(message.tCapture);
    }
    if (message.tSent !== 0) {
      writer.uint32(25).double(message.tSent);
    }
    if (message.tCaptureCamera !== undefined && message.tCaptureCamera !== 0) {
      writer.uint32(65).double(message.tCaptureCamera);
    }
    if (message.cameraId !== 0) {
      writer.uint32(32).uint32(message.cameraId);
    }
    for (const v of message.balls) {
      SSLDetectionBall.encode(v!, writer.uint32(42).fork()).ldelim();
    }
    for (const v of message.robotsYellow) {
      SSLDetectionRobot.encode(v!, writer.uint32(50).fork()).ldelim();
    }
    for (const v of message.robotsBlue) {
      SSLDetectionRobot.encode(v!, writer.uint32(58).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SSLDetectionFrame {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSSLDetectionFrame();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.frameNumber = reader.uint32();
          continue;
        case 2:
          if (tag !== 17) {
            break;
          }

          message.tCapture = reader.double();
          continue;
        case 3:
          if (tag !== 25) {
            break;
          }

          message.tSent = reader.double();
          continue;
        case 8:
          if (tag !== 65) {
            break;
          }

          message.tCaptureCamera = reader.double();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.cameraId = reader.uint32();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.balls.push(SSLDetectionBall.decode(reader, reader.uint32()));
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.robotsYellow.push(SSLDetectionRobot.decode(reader, reader.uint32()));
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.robotsBlue.push(SSLDetectionRobot.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SSLDetectionFrame {
    return {
      frameNumber: isSet(object.frameNumber) ? globalThis.Number(object.frameNumber) : 0,
      tCapture: isSet(object.tCapture) ? globalThis.Number(object.tCapture) : 0,
      tSent: isSet(object.tSent) ? globalThis.Number(object.tSent) : 0,
      tCaptureCamera: isSet(object.tCaptureCamera) ? globalThis.Number(object.tCaptureCamera) : 0,
      cameraId: isSet(object.cameraId) ? globalThis.Number(object.cameraId) : 0,
      balls: globalThis.Array.isArray(object?.balls) ? object.balls.map((e: any) => SSLDetectionBall.fromJSON(e)) : [],
      robotsYellow: globalThis.Array.isArray(object?.robotsYellow)
        ? object.robotsYellow.map((e: any) => SSLDetectionRobot.fromJSON(e))
        : [],
      robotsBlue: globalThis.Array.isArray(object?.robotsBlue)
        ? object.robotsBlue.map((e: any) => SSLDetectionRobot.fromJSON(e))
        : [],
    };
  },

  toJSON(message: SSLDetectionFrame): unknown {
    const obj: any = {};
    if (message.frameNumber !== 0) {
      obj.frameNumber = Math.round(message.frameNumber);
    }
    if (message.tCapture !== 0) {
      obj.tCapture = message.tCapture;
    }
    if (message.tSent !== 0) {
      obj.tSent = message.tSent;
    }
    if (message.tCaptureCamera !== undefined && message.tCaptureCamera !== 0) {
      obj.tCaptureCamera = message.tCaptureCamera;
    }
    if (message.cameraId !== 0) {
      obj.cameraId = Math.round(message.cameraId);
    }
    if (message.balls?.length) {
      obj.balls = message.balls.map((e) => SSLDetectionBall.toJSON(e));
    }
    if (message.robotsYellow?.length) {
      obj.robotsYellow = message.robotsYellow.map((e) => SSLDetectionRobot.toJSON(e));
    }
    if (message.robotsBlue?.length) {
      obj.robotsBlue = message.robotsBlue.map((e) => SSLDetectionRobot.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SSLDetectionFrame>, I>>(base?: I): SSLDetectionFrame {
    return SSLDetectionFrame.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SSLDetectionFrame>, I>>(object: I): SSLDetectionFrame {
    const message = createBaseSSLDetectionFrame();
    message.frameNumber = object.frameNumber ?? 0;
    message.tCapture = object.tCapture ?? 0;
    message.tSent = object.tSent ?? 0;
    message.tCaptureCamera = object.tCaptureCamera ?? 0;
    message.cameraId = object.cameraId ?? 0;
    message.balls = object.balls?.map((e) => SSLDetectionBall.fromPartial(e)) || [];
    message.robotsYellow = object.robotsYellow?.map((e) => SSLDetectionRobot.fromPartial(e)) || [];
    message.robotsBlue = object.robotsBlue?.map((e) => SSLDetectionRobot.fromPartial(e)) || [];
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}
