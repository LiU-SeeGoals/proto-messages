// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.181.1
//   protoc               v3.12.4
// source: ssl_vision/ssl_vision_geometry.proto

/* eslint-disable */
import * as _m0 from "protobufjs/minimal";

export const protobufPackage = "";

export enum SSLFieldShapeType {
  Undefined = 0,
  CenterCircle = 1,
  TopTouchLine = 2,
  BottomTouchLine = 3,
  LeftGoalLine = 4,
  RightGoalLine = 5,
  HalfwayLine = 6,
  CenterLine = 7,
  LeftPenaltyStretch = 8,
  RightPenaltyStretch = 9,
  LeftFieldLeftPenaltyStretch = 10,
  LeftFieldRightPenaltyStretch = 11,
  RightFieldLeftPenaltyStretch = 12,
  RightFieldRightPenaltyStretch = 13,
  UNRECOGNIZED = -1,
}

export function sSLFieldShapeTypeFromJSON(object: any): SSLFieldShapeType {
  switch (object) {
    case 0:
    case "Undefined":
      return SSLFieldShapeType.Undefined;
    case 1:
    case "CenterCircle":
      return SSLFieldShapeType.CenterCircle;
    case 2:
    case "TopTouchLine":
      return SSLFieldShapeType.TopTouchLine;
    case 3:
    case "BottomTouchLine":
      return SSLFieldShapeType.BottomTouchLine;
    case 4:
    case "LeftGoalLine":
      return SSLFieldShapeType.LeftGoalLine;
    case 5:
    case "RightGoalLine":
      return SSLFieldShapeType.RightGoalLine;
    case 6:
    case "HalfwayLine":
      return SSLFieldShapeType.HalfwayLine;
    case 7:
    case "CenterLine":
      return SSLFieldShapeType.CenterLine;
    case 8:
    case "LeftPenaltyStretch":
      return SSLFieldShapeType.LeftPenaltyStretch;
    case 9:
    case "RightPenaltyStretch":
      return SSLFieldShapeType.RightPenaltyStretch;
    case 10:
    case "LeftFieldLeftPenaltyStretch":
      return SSLFieldShapeType.LeftFieldLeftPenaltyStretch;
    case 11:
    case "LeftFieldRightPenaltyStretch":
      return SSLFieldShapeType.LeftFieldRightPenaltyStretch;
    case 12:
    case "RightFieldLeftPenaltyStretch":
      return SSLFieldShapeType.RightFieldLeftPenaltyStretch;
    case 13:
    case "RightFieldRightPenaltyStretch":
      return SSLFieldShapeType.RightFieldRightPenaltyStretch;
    case -1:
    case "UNRECOGNIZED":
    default:
      return SSLFieldShapeType.UNRECOGNIZED;
  }
}

export function sSLFieldShapeTypeToJSON(object: SSLFieldShapeType): string {
  switch (object) {
    case SSLFieldShapeType.Undefined:
      return "Undefined";
    case SSLFieldShapeType.CenterCircle:
      return "CenterCircle";
    case SSLFieldShapeType.TopTouchLine:
      return "TopTouchLine";
    case SSLFieldShapeType.BottomTouchLine:
      return "BottomTouchLine";
    case SSLFieldShapeType.LeftGoalLine:
      return "LeftGoalLine";
    case SSLFieldShapeType.RightGoalLine:
      return "RightGoalLine";
    case SSLFieldShapeType.HalfwayLine:
      return "HalfwayLine";
    case SSLFieldShapeType.CenterLine:
      return "CenterLine";
    case SSLFieldShapeType.LeftPenaltyStretch:
      return "LeftPenaltyStretch";
    case SSLFieldShapeType.RightPenaltyStretch:
      return "RightPenaltyStretch";
    case SSLFieldShapeType.LeftFieldLeftPenaltyStretch:
      return "LeftFieldLeftPenaltyStretch";
    case SSLFieldShapeType.LeftFieldRightPenaltyStretch:
      return "LeftFieldRightPenaltyStretch";
    case SSLFieldShapeType.RightFieldLeftPenaltyStretch:
      return "RightFieldLeftPenaltyStretch";
    case SSLFieldShapeType.RightFieldRightPenaltyStretch:
      return "RightFieldRightPenaltyStretch";
    case SSLFieldShapeType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** A 2D float vector. */
export interface Vector2f {
  x: number;
  y: number;
}

/**
 * Represents a field marking as a line segment represented by a start point p1,
 * and end point p2, and a line thickness. The start and end points are along
 * the center of the line, so the thickness of the line extends by thickness / 2
 * on either side of the line.
 */
export interface SSLFieldLineSegment {
  /** Name of this field marking. */
  name: string;
  /** Start point of the line segment. */
  p1:
    | Vector2f
    | undefined;
  /** End point of the line segment. */
  p2:
    | Vector2f
    | undefined;
  /** Thickness of the line segment. */
  thickness: number;
  /** The type of this shape */
  type?: SSLFieldShapeType | undefined;
}

/**
 * Represents a field marking as a circular arc segment represented by center point, a
 * start angle, an end angle, and an arc thickness.
 */
export interface SSLFieldCircularArc {
  /** Name of this field marking. */
  name: string;
  /** Center point of the circular arc. */
  center:
    | Vector2f
    | undefined;
  /** Radius of the arc. */
  radius: number;
  /** Start angle in counter-clockwise order. */
  a1: number;
  /** End angle in counter-clockwise order. */
  a2: number;
  /** Thickness of the arc. */
  thickness: number;
  /** The type of this shape */
  type?: SSLFieldShapeType | undefined;
}

export interface SSLGeometryFieldSize {
  fieldLength: number;
  fieldWidth: number;
  goalWidth: number;
  goalDepth: number;
  boundaryWidth: number;
  fieldLines: SSLFieldLineSegment[];
  fieldArcs: SSLFieldCircularArc[];
  penaltyAreaDepth?: number | undefined;
  penaltyAreaWidth?: number | undefined;
}

export interface SSLGeometryCameraCalibration {
  cameraId: number;
  focalLength: number;
  principalPointX: number;
  principalPointY: number;
  distortion: number;
  q0: number;
  q1: number;
  q2: number;
  q3: number;
  tx: number;
  ty: number;
  tz: number;
  derivedCameraWorldTx?: number | undefined;
  derivedCameraWorldTy?: number | undefined;
  derivedCameraWorldTz?: number | undefined;
  pixelImageWidth?: number | undefined;
  pixelImageHeight?: number | undefined;
}

/**
 * Two-Phase model for straight-kicked balls.
 * There are two phases with different accelerations during the ball kicks:
 * 1. Sliding
 * 2. Rolling
 * The full model is described in the TDP of ER-Force from 2016, which can be found here:
 * https://ssl.robocup.org/wp-content/uploads/2019/01/2016_ETDP_ER-Force.pdf
 */
export interface SSLBallModelStraightTwoPhase {
  /** Ball sliding acceleration [m/s^2] (should be negative) */
  accSlide: number;
  /** Ball rolling acceleration [m/s^2] (should be negative) */
  accRoll: number;
  /** Fraction of the initial velocity where the ball starts to roll */
  kSwitch: number;
}

/**
 * Fixed-Loss model for chipped balls.
 * Uses fixed damping factors for xy and z direction per hop.
 */
export interface SSLBallModelChipFixedLoss {
  /** Chip kick velocity damping factor in XY direction for the first hop */
  dampingXyFirstHop: number;
  /** Chip kick velocity damping factor in XY direction for all following hops */
  dampingXyOtherHops: number;
  /** Chip kick velocity damping factor in Z direction for all hops */
  dampingZ: number;
}

export interface SSLGeometryModels {
  straightTwoPhase?: SSLBallModelStraightTwoPhase | undefined;
  chipFixedLoss?: SSLBallModelChipFixedLoss | undefined;
}

export interface SSLGeometryData {
  field: SSLGeometryFieldSize | undefined;
  calib: SSLGeometryCameraCalibration[];
  models?: SSLGeometryModels | undefined;
}

function createBaseVector2f(): Vector2f {
  return { x: 0, y: 0 };
}

export const Vector2f = {
  encode(message: Vector2f, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.x !== 0) {
      writer.uint32(13).float(message.x);
    }
    if (message.y !== 0) {
      writer.uint32(21).float(message.y);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Vector2f {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVector2f();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 13) {
            break;
          }

          message.x = reader.float();
          continue;
        case 2:
          if (tag !== 21) {
            break;
          }

          message.y = reader.float();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Vector2f {
    return {
      x: isSet(object.x) ? globalThis.Number(object.x) : 0,
      y: isSet(object.y) ? globalThis.Number(object.y) : 0,
    };
  },

  toJSON(message: Vector2f): unknown {
    const obj: any = {};
    if (message.x !== 0) {
      obj.x = message.x;
    }
    if (message.y !== 0) {
      obj.y = message.y;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Vector2f>, I>>(base?: I): Vector2f {
    return Vector2f.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Vector2f>, I>>(object: I): Vector2f {
    const message = createBaseVector2f();
    message.x = object.x ?? 0;
    message.y = object.y ?? 0;
    return message;
  },
};

function createBaseSSLFieldLineSegment(): SSLFieldLineSegment {
  return { name: "", p1: undefined, p2: undefined, thickness: 0, type: 0 };
}

export const SSLFieldLineSegment = {
  encode(message: SSLFieldLineSegment, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.p1 !== undefined) {
      Vector2f.encode(message.p1, writer.uint32(18).fork()).ldelim();
    }
    if (message.p2 !== undefined) {
      Vector2f.encode(message.p2, writer.uint32(26).fork()).ldelim();
    }
    if (message.thickness !== 0) {
      writer.uint32(37).float(message.thickness);
    }
    if (message.type !== undefined && message.type !== 0) {
      writer.uint32(40).int32(message.type);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SSLFieldLineSegment {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSSLFieldLineSegment();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.p1 = Vector2f.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.p2 = Vector2f.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 37) {
            break;
          }

          message.thickness = reader.float();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SSLFieldLineSegment {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      p1: isSet(object.p1) ? Vector2f.fromJSON(object.p1) : undefined,
      p2: isSet(object.p2) ? Vector2f.fromJSON(object.p2) : undefined,
      thickness: isSet(object.thickness) ? globalThis.Number(object.thickness) : 0,
      type: isSet(object.type) ? sSLFieldShapeTypeFromJSON(object.type) : 0,
    };
  },

  toJSON(message: SSLFieldLineSegment): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.p1 !== undefined) {
      obj.p1 = Vector2f.toJSON(message.p1);
    }
    if (message.p2 !== undefined) {
      obj.p2 = Vector2f.toJSON(message.p2);
    }
    if (message.thickness !== 0) {
      obj.thickness = message.thickness;
    }
    if (message.type !== undefined && message.type !== 0) {
      obj.type = sSLFieldShapeTypeToJSON(message.type);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SSLFieldLineSegment>, I>>(base?: I): SSLFieldLineSegment {
    return SSLFieldLineSegment.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SSLFieldLineSegment>, I>>(object: I): SSLFieldLineSegment {
    const message = createBaseSSLFieldLineSegment();
    message.name = object.name ?? "";
    message.p1 = (object.p1 !== undefined && object.p1 !== null) ? Vector2f.fromPartial(object.p1) : undefined;
    message.p2 = (object.p2 !== undefined && object.p2 !== null) ? Vector2f.fromPartial(object.p2) : undefined;
    message.thickness = object.thickness ?? 0;
    message.type = object.type ?? 0;
    return message;
  },
};

function createBaseSSLFieldCircularArc(): SSLFieldCircularArc {
  return { name: "", center: undefined, radius: 0, a1: 0, a2: 0, thickness: 0, type: 0 };
}

export const SSLFieldCircularArc = {
  encode(message: SSLFieldCircularArc, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.center !== undefined) {
      Vector2f.encode(message.center, writer.uint32(18).fork()).ldelim();
    }
    if (message.radius !== 0) {
      writer.uint32(29).float(message.radius);
    }
    if (message.a1 !== 0) {
      writer.uint32(37).float(message.a1);
    }
    if (message.a2 !== 0) {
      writer.uint32(45).float(message.a2);
    }
    if (message.thickness !== 0) {
      writer.uint32(53).float(message.thickness);
    }
    if (message.type !== undefined && message.type !== 0) {
      writer.uint32(56).int32(message.type);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SSLFieldCircularArc {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSSLFieldCircularArc();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.center = Vector2f.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 29) {
            break;
          }

          message.radius = reader.float();
          continue;
        case 4:
          if (tag !== 37) {
            break;
          }

          message.a1 = reader.float();
          continue;
        case 5:
          if (tag !== 45) {
            break;
          }

          message.a2 = reader.float();
          continue;
        case 6:
          if (tag !== 53) {
            break;
          }

          message.thickness = reader.float();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SSLFieldCircularArc {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      center: isSet(object.center) ? Vector2f.fromJSON(object.center) : undefined,
      radius: isSet(object.radius) ? globalThis.Number(object.radius) : 0,
      a1: isSet(object.a1) ? globalThis.Number(object.a1) : 0,
      a2: isSet(object.a2) ? globalThis.Number(object.a2) : 0,
      thickness: isSet(object.thickness) ? globalThis.Number(object.thickness) : 0,
      type: isSet(object.type) ? sSLFieldShapeTypeFromJSON(object.type) : 0,
    };
  },

  toJSON(message: SSLFieldCircularArc): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.center !== undefined) {
      obj.center = Vector2f.toJSON(message.center);
    }
    if (message.radius !== 0) {
      obj.radius = message.radius;
    }
    if (message.a1 !== 0) {
      obj.a1 = message.a1;
    }
    if (message.a2 !== 0) {
      obj.a2 = message.a2;
    }
    if (message.thickness !== 0) {
      obj.thickness = message.thickness;
    }
    if (message.type !== undefined && message.type !== 0) {
      obj.type = sSLFieldShapeTypeToJSON(message.type);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SSLFieldCircularArc>, I>>(base?: I): SSLFieldCircularArc {
    return SSLFieldCircularArc.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SSLFieldCircularArc>, I>>(object: I): SSLFieldCircularArc {
    const message = createBaseSSLFieldCircularArc();
    message.name = object.name ?? "";
    message.center = (object.center !== undefined && object.center !== null)
      ? Vector2f.fromPartial(object.center)
      : undefined;
    message.radius = object.radius ?? 0;
    message.a1 = object.a1 ?? 0;
    message.a2 = object.a2 ?? 0;
    message.thickness = object.thickness ?? 0;
    message.type = object.type ?? 0;
    return message;
  },
};

function createBaseSSLGeometryFieldSize(): SSLGeometryFieldSize {
  return {
    fieldLength: 0,
    fieldWidth: 0,
    goalWidth: 0,
    goalDepth: 0,
    boundaryWidth: 0,
    fieldLines: [],
    fieldArcs: [],
    penaltyAreaDepth: 0,
    penaltyAreaWidth: 0,
  };
}

export const SSLGeometryFieldSize = {
  encode(message: SSLGeometryFieldSize, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.fieldLength !== 0) {
      writer.uint32(8).int32(message.fieldLength);
    }
    if (message.fieldWidth !== 0) {
      writer.uint32(16).int32(message.fieldWidth);
    }
    if (message.goalWidth !== 0) {
      writer.uint32(24).int32(message.goalWidth);
    }
    if (message.goalDepth !== 0) {
      writer.uint32(32).int32(message.goalDepth);
    }
    if (message.boundaryWidth !== 0) {
      writer.uint32(40).int32(message.boundaryWidth);
    }
    for (const v of message.fieldLines) {
      SSLFieldLineSegment.encode(v!, writer.uint32(50).fork()).ldelim();
    }
    for (const v of message.fieldArcs) {
      SSLFieldCircularArc.encode(v!, writer.uint32(58).fork()).ldelim();
    }
    if (message.penaltyAreaDepth !== undefined && message.penaltyAreaDepth !== 0) {
      writer.uint32(64).int32(message.penaltyAreaDepth);
    }
    if (message.penaltyAreaWidth !== undefined && message.penaltyAreaWidth !== 0) {
      writer.uint32(72).int32(message.penaltyAreaWidth);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SSLGeometryFieldSize {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSSLGeometryFieldSize();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.fieldLength = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.fieldWidth = reader.int32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.goalWidth = reader.int32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.goalDepth = reader.int32();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.boundaryWidth = reader.int32();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.fieldLines.push(SSLFieldLineSegment.decode(reader, reader.uint32()));
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.fieldArcs.push(SSLFieldCircularArc.decode(reader, reader.uint32()));
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.penaltyAreaDepth = reader.int32();
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.penaltyAreaWidth = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SSLGeometryFieldSize {
    return {
      fieldLength: isSet(object.fieldLength) ? globalThis.Number(object.fieldLength) : 0,
      fieldWidth: isSet(object.fieldWidth) ? globalThis.Number(object.fieldWidth) : 0,
      goalWidth: isSet(object.goalWidth) ? globalThis.Number(object.goalWidth) : 0,
      goalDepth: isSet(object.goalDepth) ? globalThis.Number(object.goalDepth) : 0,
      boundaryWidth: isSet(object.boundaryWidth) ? globalThis.Number(object.boundaryWidth) : 0,
      fieldLines: globalThis.Array.isArray(object?.fieldLines)
        ? object.fieldLines.map((e: any) => SSLFieldLineSegment.fromJSON(e))
        : [],
      fieldArcs: globalThis.Array.isArray(object?.fieldArcs)
        ? object.fieldArcs.map((e: any) => SSLFieldCircularArc.fromJSON(e))
        : [],
      penaltyAreaDepth: isSet(object.penaltyAreaDepth) ? globalThis.Number(object.penaltyAreaDepth) : 0,
      penaltyAreaWidth: isSet(object.penaltyAreaWidth) ? globalThis.Number(object.penaltyAreaWidth) : 0,
    };
  },

  toJSON(message: SSLGeometryFieldSize): unknown {
    const obj: any = {};
    if (message.fieldLength !== 0) {
      obj.fieldLength = Math.round(message.fieldLength);
    }
    if (message.fieldWidth !== 0) {
      obj.fieldWidth = Math.round(message.fieldWidth);
    }
    if (message.goalWidth !== 0) {
      obj.goalWidth = Math.round(message.goalWidth);
    }
    if (message.goalDepth !== 0) {
      obj.goalDepth = Math.round(message.goalDepth);
    }
    if (message.boundaryWidth !== 0) {
      obj.boundaryWidth = Math.round(message.boundaryWidth);
    }
    if (message.fieldLines?.length) {
      obj.fieldLines = message.fieldLines.map((e) => SSLFieldLineSegment.toJSON(e));
    }
    if (message.fieldArcs?.length) {
      obj.fieldArcs = message.fieldArcs.map((e) => SSLFieldCircularArc.toJSON(e));
    }
    if (message.penaltyAreaDepth !== undefined && message.penaltyAreaDepth !== 0) {
      obj.penaltyAreaDepth = Math.round(message.penaltyAreaDepth);
    }
    if (message.penaltyAreaWidth !== undefined && message.penaltyAreaWidth !== 0) {
      obj.penaltyAreaWidth = Math.round(message.penaltyAreaWidth);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SSLGeometryFieldSize>, I>>(base?: I): SSLGeometryFieldSize {
    return SSLGeometryFieldSize.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SSLGeometryFieldSize>, I>>(object: I): SSLGeometryFieldSize {
    const message = createBaseSSLGeometryFieldSize();
    message.fieldLength = object.fieldLength ?? 0;
    message.fieldWidth = object.fieldWidth ?? 0;
    message.goalWidth = object.goalWidth ?? 0;
    message.goalDepth = object.goalDepth ?? 0;
    message.boundaryWidth = object.boundaryWidth ?? 0;
    message.fieldLines = object.fieldLines?.map((e) => SSLFieldLineSegment.fromPartial(e)) || [];
    message.fieldArcs = object.fieldArcs?.map((e) => SSLFieldCircularArc.fromPartial(e)) || [];
    message.penaltyAreaDepth = object.penaltyAreaDepth ?? 0;
    message.penaltyAreaWidth = object.penaltyAreaWidth ?? 0;
    return message;
  },
};

function createBaseSSLGeometryCameraCalibration(): SSLGeometryCameraCalibration {
  return {
    cameraId: 0,
    focalLength: 0,
    principalPointX: 0,
    principalPointY: 0,
    distortion: 0,
    q0: 0,
    q1: 0,
    q2: 0,
    q3: 0,
    tx: 0,
    ty: 0,
    tz: 0,
    derivedCameraWorldTx: 0,
    derivedCameraWorldTy: 0,
    derivedCameraWorldTz: 0,
    pixelImageWidth: 0,
    pixelImageHeight: 0,
  };
}

export const SSLGeometryCameraCalibration = {
  encode(message: SSLGeometryCameraCalibration, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.cameraId !== 0) {
      writer.uint32(8).uint32(message.cameraId);
    }
    if (message.focalLength !== 0) {
      writer.uint32(21).float(message.focalLength);
    }
    if (message.principalPointX !== 0) {
      writer.uint32(29).float(message.principalPointX);
    }
    if (message.principalPointY !== 0) {
      writer.uint32(37).float(message.principalPointY);
    }
    if (message.distortion !== 0) {
      writer.uint32(45).float(message.distortion);
    }
    if (message.q0 !== 0) {
      writer.uint32(53).float(message.q0);
    }
    if (message.q1 !== 0) {
      writer.uint32(61).float(message.q1);
    }
    if (message.q2 !== 0) {
      writer.uint32(69).float(message.q2);
    }
    if (message.q3 !== 0) {
      writer.uint32(77).float(message.q3);
    }
    if (message.tx !== 0) {
      writer.uint32(85).float(message.tx);
    }
    if (message.ty !== 0) {
      writer.uint32(93).float(message.ty);
    }
    if (message.tz !== 0) {
      writer.uint32(101).float(message.tz);
    }
    if (message.derivedCameraWorldTx !== undefined && message.derivedCameraWorldTx !== 0) {
      writer.uint32(109).float(message.derivedCameraWorldTx);
    }
    if (message.derivedCameraWorldTy !== undefined && message.derivedCameraWorldTy !== 0) {
      writer.uint32(117).float(message.derivedCameraWorldTy);
    }
    if (message.derivedCameraWorldTz !== undefined && message.derivedCameraWorldTz !== 0) {
      writer.uint32(125).float(message.derivedCameraWorldTz);
    }
    if (message.pixelImageWidth !== undefined && message.pixelImageWidth !== 0) {
      writer.uint32(128).uint32(message.pixelImageWidth);
    }
    if (message.pixelImageHeight !== undefined && message.pixelImageHeight !== 0) {
      writer.uint32(136).uint32(message.pixelImageHeight);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SSLGeometryCameraCalibration {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSSLGeometryCameraCalibration();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.cameraId = reader.uint32();
          continue;
        case 2:
          if (tag !== 21) {
            break;
          }

          message.focalLength = reader.float();
          continue;
        case 3:
          if (tag !== 29) {
            break;
          }

          message.principalPointX = reader.float();
          continue;
        case 4:
          if (tag !== 37) {
            break;
          }

          message.principalPointY = reader.float();
          continue;
        case 5:
          if (tag !== 45) {
            break;
          }

          message.distortion = reader.float();
          continue;
        case 6:
          if (tag !== 53) {
            break;
          }

          message.q0 = reader.float();
          continue;
        case 7:
          if (tag !== 61) {
            break;
          }

          message.q1 = reader.float();
          continue;
        case 8:
          if (tag !== 69) {
            break;
          }

          message.q2 = reader.float();
          continue;
        case 9:
          if (tag !== 77) {
            break;
          }

          message.q3 = reader.float();
          continue;
        case 10:
          if (tag !== 85) {
            break;
          }

          message.tx = reader.float();
          continue;
        case 11:
          if (tag !== 93) {
            break;
          }

          message.ty = reader.float();
          continue;
        case 12:
          if (tag !== 101) {
            break;
          }

          message.tz = reader.float();
          continue;
        case 13:
          if (tag !== 109) {
            break;
          }

          message.derivedCameraWorldTx = reader.float();
          continue;
        case 14:
          if (tag !== 117) {
            break;
          }

          message.derivedCameraWorldTy = reader.float();
          continue;
        case 15:
          if (tag !== 125) {
            break;
          }

          message.derivedCameraWorldTz = reader.float();
          continue;
        case 16:
          if (tag !== 128) {
            break;
          }

          message.pixelImageWidth = reader.uint32();
          continue;
        case 17:
          if (tag !== 136) {
            break;
          }

          message.pixelImageHeight = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SSLGeometryCameraCalibration {
    return {
      cameraId: isSet(object.cameraId) ? globalThis.Number(object.cameraId) : 0,
      focalLength: isSet(object.focalLength) ? globalThis.Number(object.focalLength) : 0,
      principalPointX: isSet(object.principalPointX) ? globalThis.Number(object.principalPointX) : 0,
      principalPointY: isSet(object.principalPointY) ? globalThis.Number(object.principalPointY) : 0,
      distortion: isSet(object.distortion) ? globalThis.Number(object.distortion) : 0,
      q0: isSet(object.q0) ? globalThis.Number(object.q0) : 0,
      q1: isSet(object.q1) ? globalThis.Number(object.q1) : 0,
      q2: isSet(object.q2) ? globalThis.Number(object.q2) : 0,
      q3: isSet(object.q3) ? globalThis.Number(object.q3) : 0,
      tx: isSet(object.tx) ? globalThis.Number(object.tx) : 0,
      ty: isSet(object.ty) ? globalThis.Number(object.ty) : 0,
      tz: isSet(object.tz) ? globalThis.Number(object.tz) : 0,
      derivedCameraWorldTx: isSet(object.derivedCameraWorldTx) ? globalThis.Number(object.derivedCameraWorldTx) : 0,
      derivedCameraWorldTy: isSet(object.derivedCameraWorldTy) ? globalThis.Number(object.derivedCameraWorldTy) : 0,
      derivedCameraWorldTz: isSet(object.derivedCameraWorldTz) ? globalThis.Number(object.derivedCameraWorldTz) : 0,
      pixelImageWidth: isSet(object.pixelImageWidth) ? globalThis.Number(object.pixelImageWidth) : 0,
      pixelImageHeight: isSet(object.pixelImageHeight) ? globalThis.Number(object.pixelImageHeight) : 0,
    };
  },

  toJSON(message: SSLGeometryCameraCalibration): unknown {
    const obj: any = {};
    if (message.cameraId !== 0) {
      obj.cameraId = Math.round(message.cameraId);
    }
    if (message.focalLength !== 0) {
      obj.focalLength = message.focalLength;
    }
    if (message.principalPointX !== 0) {
      obj.principalPointX = message.principalPointX;
    }
    if (message.principalPointY !== 0) {
      obj.principalPointY = message.principalPointY;
    }
    if (message.distortion !== 0) {
      obj.distortion = message.distortion;
    }
    if (message.q0 !== 0) {
      obj.q0 = message.q0;
    }
    if (message.q1 !== 0) {
      obj.q1 = message.q1;
    }
    if (message.q2 !== 0) {
      obj.q2 = message.q2;
    }
    if (message.q3 !== 0) {
      obj.q3 = message.q3;
    }
    if (message.tx !== 0) {
      obj.tx = message.tx;
    }
    if (message.ty !== 0) {
      obj.ty = message.ty;
    }
    if (message.tz !== 0) {
      obj.tz = message.tz;
    }
    if (message.derivedCameraWorldTx !== undefined && message.derivedCameraWorldTx !== 0) {
      obj.derivedCameraWorldTx = message.derivedCameraWorldTx;
    }
    if (message.derivedCameraWorldTy !== undefined && message.derivedCameraWorldTy !== 0) {
      obj.derivedCameraWorldTy = message.derivedCameraWorldTy;
    }
    if (message.derivedCameraWorldTz !== undefined && message.derivedCameraWorldTz !== 0) {
      obj.derivedCameraWorldTz = message.derivedCameraWorldTz;
    }
    if (message.pixelImageWidth !== undefined && message.pixelImageWidth !== 0) {
      obj.pixelImageWidth = Math.round(message.pixelImageWidth);
    }
    if (message.pixelImageHeight !== undefined && message.pixelImageHeight !== 0) {
      obj.pixelImageHeight = Math.round(message.pixelImageHeight);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SSLGeometryCameraCalibration>, I>>(base?: I): SSLGeometryCameraCalibration {
    return SSLGeometryCameraCalibration.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SSLGeometryCameraCalibration>, I>>(object: I): SSLGeometryCameraCalibration {
    const message = createBaseSSLGeometryCameraCalibration();
    message.cameraId = object.cameraId ?? 0;
    message.focalLength = object.focalLength ?? 0;
    message.principalPointX = object.principalPointX ?? 0;
    message.principalPointY = object.principalPointY ?? 0;
    message.distortion = object.distortion ?? 0;
    message.q0 = object.q0 ?? 0;
    message.q1 = object.q1 ?? 0;
    message.q2 = object.q2 ?? 0;
    message.q3 = object.q3 ?? 0;
    message.tx = object.tx ?? 0;
    message.ty = object.ty ?? 0;
    message.tz = object.tz ?? 0;
    message.derivedCameraWorldTx = object.derivedCameraWorldTx ?? 0;
    message.derivedCameraWorldTy = object.derivedCameraWorldTy ?? 0;
    message.derivedCameraWorldTz = object.derivedCameraWorldTz ?? 0;
    message.pixelImageWidth = object.pixelImageWidth ?? 0;
    message.pixelImageHeight = object.pixelImageHeight ?? 0;
    return message;
  },
};

function createBaseSSLBallModelStraightTwoPhase(): SSLBallModelStraightTwoPhase {
  return { accSlide: 0, accRoll: 0, kSwitch: 0 };
}

export const SSLBallModelStraightTwoPhase = {
  encode(message: SSLBallModelStraightTwoPhase, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.accSlide !== 0) {
      writer.uint32(9).double(message.accSlide);
    }
    if (message.accRoll !== 0) {
      writer.uint32(17).double(message.accRoll);
    }
    if (message.kSwitch !== 0) {
      writer.uint32(25).double(message.kSwitch);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SSLBallModelStraightTwoPhase {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSSLBallModelStraightTwoPhase();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 9) {
            break;
          }

          message.accSlide = reader.double();
          continue;
        case 2:
          if (tag !== 17) {
            break;
          }

          message.accRoll = reader.double();
          continue;
        case 3:
          if (tag !== 25) {
            break;
          }

          message.kSwitch = reader.double();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SSLBallModelStraightTwoPhase {
    return {
      accSlide: isSet(object.accSlide) ? globalThis.Number(object.accSlide) : 0,
      accRoll: isSet(object.accRoll) ? globalThis.Number(object.accRoll) : 0,
      kSwitch: isSet(object.kSwitch) ? globalThis.Number(object.kSwitch) : 0,
    };
  },

  toJSON(message: SSLBallModelStraightTwoPhase): unknown {
    const obj: any = {};
    if (message.accSlide !== 0) {
      obj.accSlide = message.accSlide;
    }
    if (message.accRoll !== 0) {
      obj.accRoll = message.accRoll;
    }
    if (message.kSwitch !== 0) {
      obj.kSwitch = message.kSwitch;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SSLBallModelStraightTwoPhase>, I>>(base?: I): SSLBallModelStraightTwoPhase {
    return SSLBallModelStraightTwoPhase.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SSLBallModelStraightTwoPhase>, I>>(object: I): SSLBallModelStraightTwoPhase {
    const message = createBaseSSLBallModelStraightTwoPhase();
    message.accSlide = object.accSlide ?? 0;
    message.accRoll = object.accRoll ?? 0;
    message.kSwitch = object.kSwitch ?? 0;
    return message;
  },
};

function createBaseSSLBallModelChipFixedLoss(): SSLBallModelChipFixedLoss {
  return { dampingXyFirstHop: 0, dampingXyOtherHops: 0, dampingZ: 0 };
}

export const SSLBallModelChipFixedLoss = {
  encode(message: SSLBallModelChipFixedLoss, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.dampingXyFirstHop !== 0) {
      writer.uint32(9).double(message.dampingXyFirstHop);
    }
    if (message.dampingXyOtherHops !== 0) {
      writer.uint32(17).double(message.dampingXyOtherHops);
    }
    if (message.dampingZ !== 0) {
      writer.uint32(25).double(message.dampingZ);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SSLBallModelChipFixedLoss {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSSLBallModelChipFixedLoss();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 9) {
            break;
          }

          message.dampingXyFirstHop = reader.double();
          continue;
        case 2:
          if (tag !== 17) {
            break;
          }

          message.dampingXyOtherHops = reader.double();
          continue;
        case 3:
          if (tag !== 25) {
            break;
          }

          message.dampingZ = reader.double();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SSLBallModelChipFixedLoss {
    return {
      dampingXyFirstHop: isSet(object.dampingXyFirstHop) ? globalThis.Number(object.dampingXyFirstHop) : 0,
      dampingXyOtherHops: isSet(object.dampingXyOtherHops) ? globalThis.Number(object.dampingXyOtherHops) : 0,
      dampingZ: isSet(object.dampingZ) ? globalThis.Number(object.dampingZ) : 0,
    };
  },

  toJSON(message: SSLBallModelChipFixedLoss): unknown {
    const obj: any = {};
    if (message.dampingXyFirstHop !== 0) {
      obj.dampingXyFirstHop = message.dampingXyFirstHop;
    }
    if (message.dampingXyOtherHops !== 0) {
      obj.dampingXyOtherHops = message.dampingXyOtherHops;
    }
    if (message.dampingZ !== 0) {
      obj.dampingZ = message.dampingZ;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SSLBallModelChipFixedLoss>, I>>(base?: I): SSLBallModelChipFixedLoss {
    return SSLBallModelChipFixedLoss.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SSLBallModelChipFixedLoss>, I>>(object: I): SSLBallModelChipFixedLoss {
    const message = createBaseSSLBallModelChipFixedLoss();
    message.dampingXyFirstHop = object.dampingXyFirstHop ?? 0;
    message.dampingXyOtherHops = object.dampingXyOtherHops ?? 0;
    message.dampingZ = object.dampingZ ?? 0;
    return message;
  },
};

function createBaseSSLGeometryModels(): SSLGeometryModels {
  return { straightTwoPhase: undefined, chipFixedLoss: undefined };
}

export const SSLGeometryModels = {
  encode(message: SSLGeometryModels, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.straightTwoPhase !== undefined) {
      SSLBallModelStraightTwoPhase.encode(message.straightTwoPhase, writer.uint32(10).fork()).ldelim();
    }
    if (message.chipFixedLoss !== undefined) {
      SSLBallModelChipFixedLoss.encode(message.chipFixedLoss, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SSLGeometryModels {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSSLGeometryModels();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.straightTwoPhase = SSLBallModelStraightTwoPhase.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.chipFixedLoss = SSLBallModelChipFixedLoss.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SSLGeometryModels {
    return {
      straightTwoPhase: isSet(object.straightTwoPhase)
        ? SSLBallModelStraightTwoPhase.fromJSON(object.straightTwoPhase)
        : undefined,
      chipFixedLoss: isSet(object.chipFixedLoss) ? SSLBallModelChipFixedLoss.fromJSON(object.chipFixedLoss) : undefined,
    };
  },

  toJSON(message: SSLGeometryModels): unknown {
    const obj: any = {};
    if (message.straightTwoPhase !== undefined) {
      obj.straightTwoPhase = SSLBallModelStraightTwoPhase.toJSON(message.straightTwoPhase);
    }
    if (message.chipFixedLoss !== undefined) {
      obj.chipFixedLoss = SSLBallModelChipFixedLoss.toJSON(message.chipFixedLoss);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SSLGeometryModels>, I>>(base?: I): SSLGeometryModels {
    return SSLGeometryModels.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SSLGeometryModels>, I>>(object: I): SSLGeometryModels {
    const message = createBaseSSLGeometryModels();
    message.straightTwoPhase = (object.straightTwoPhase !== undefined && object.straightTwoPhase !== null)
      ? SSLBallModelStraightTwoPhase.fromPartial(object.straightTwoPhase)
      : undefined;
    message.chipFixedLoss = (object.chipFixedLoss !== undefined && object.chipFixedLoss !== null)
      ? SSLBallModelChipFixedLoss.fromPartial(object.chipFixedLoss)
      : undefined;
    return message;
  },
};

function createBaseSSLGeometryData(): SSLGeometryData {
  return { field: undefined, calib: [], models: undefined };
}

export const SSLGeometryData = {
  encode(message: SSLGeometryData, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.field !== undefined) {
      SSLGeometryFieldSize.encode(message.field, writer.uint32(10).fork()).ldelim();
    }
    for (const v of message.calib) {
      SSLGeometryCameraCalibration.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    if (message.models !== undefined) {
      SSLGeometryModels.encode(message.models, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SSLGeometryData {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSSLGeometryData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.field = SSLGeometryFieldSize.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.calib.push(SSLGeometryCameraCalibration.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.models = SSLGeometryModels.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SSLGeometryData {
    return {
      field: isSet(object.field) ? SSLGeometryFieldSize.fromJSON(object.field) : undefined,
      calib: globalThis.Array.isArray(object?.calib)
        ? object.calib.map((e: any) => SSLGeometryCameraCalibration.fromJSON(e))
        : [],
      models: isSet(object.models) ? SSLGeometryModels.fromJSON(object.models) : undefined,
    };
  },

  toJSON(message: SSLGeometryData): unknown {
    const obj: any = {};
    if (message.field !== undefined) {
      obj.field = SSLGeometryFieldSize.toJSON(message.field);
    }
    if (message.calib?.length) {
      obj.calib = message.calib.map((e) => SSLGeometryCameraCalibration.toJSON(e));
    }
    if (message.models !== undefined) {
      obj.models = SSLGeometryModels.toJSON(message.models);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SSLGeometryData>, I>>(base?: I): SSLGeometryData {
    return SSLGeometryData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SSLGeometryData>, I>>(object: I): SSLGeometryData {
    const message = createBaseSSLGeometryData();
    message.field = (object.field !== undefined && object.field !== null)
      ? SSLGeometryFieldSize.fromPartial(object.field)
      : undefined;
    message.calib = object.calib?.map((e) => SSLGeometryCameraCalibration.fromPartial(e)) || [];
    message.models = (object.models !== undefined && object.models !== null)
      ? SSLGeometryModels.fromPartial(object.models)
      : undefined;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}
